---
title: Azure AD Provisioning to applications via PowerShell
description: This document describes how to configure Azure AD to provision users with external systems that offer Windows PowerShell based APIs.
services: active-directory
author: billmath
manager: amycolannino
ms.service: active-directory
ms.subservice: app-provisioning
ms.topic: how-to
ms.workload: identity
ms.date: 02/08/2022
ms.author: billmath
ms.reviewer: arvinh
---

# Provisioning users into applications using PowerShell
The following documentation provides configuration and tutorial information demonstrating how the generic PowerShell connector and the ECMA Connector Host can be used to integrate Azure AD with external systems that offer Windows PowerShell based APIs.

For additional information see [Windows PowerShell Connector technical reference](/microsoft-identity-manager/reference/microsoft-identity-manager-2016-connector-powershell)


## Prerequisites for provisioning via PowerShell

### On-premises prerequisites

The connector provides a bridge between the capabilities of the ECMA Connector Host and Windows PowerShell. Before you use the Connector, make sure you have the following on the server hosting the connector



- A Windows Server 2016 or a later version. 
- At least 3 GB of RAM, to host a provisioning agent. 
- .NET Framework 4.7.2 
- Windows PowerShell 2.0, 3.0, or 4.0
-  Connectivity to the target system hosting the PowerShell API.
- The execution policy on the server must be configured to allow the connector to run Windows PowerShell scripts. Unless the scripts the connector runs are digitally signed, configure the execution policy by running this command:  
`Set-ExecutionPolicy -ExecutionPolicy RemoteSigned`
- Deploying this connector will require one or more PowerShell scripts.  Some Microsoft products may provide scripts for use with this connector, and the support statement for those scripts would be provided by that product.  If you are developing your own scripts for use with this connector, you will need to have familiarity with the [Extensible Connectivity Management Agent API](https://msdn.microsoft.com/library/windows/desktop/hh859557.aspx) to develop and maintain those scripts.  If you are integrating with third party systems using your own scripts in a production environment, we recommend you work with the third party vendor or a deployment partner for help, guidance and support for this integration.



### Cloud requirements

 - An Azure AD tenant with Azure AD Premium P1 or Premium P2 (or EMS E3 or E5).   [!INCLUDE [active-directory-p1-license.md](../../../includes/active-directory-p1-license.md)]
 - The Hybrid Identity Administrator role for configuring the provisioning agent and the Application Administrator or Cloud Application Administrator roles for configuring provisioning in the Azure portal.
 - The Azure AD users to be provisioned to the database must already be populated with any attributes that will be required by the database schema and that are not generated by the database itself.

## Download, install, and configure the Azure AD Connect Provisioning Agent Package

If you have already downloaded the provisioning agent and configured it for another on-premises application, then continue reading in the next section.

  1.  In the Azure portal, select **Azure Active Directory**.
  2.  On the left, select **Azure AD Connect**.
  3.  On the left, select **Cloud sync**.
 
 :::image type="content" source="../../../includes/media/active-directory-cloud-sync-how-to-install/new-ux-1.png" alt-text="Screenshot of new UX screen." lightbox="../../../includes/media/active-directory-cloud-sync-how-to-install/new-ux-1.png":::

 4. On the left, select **Agent**.
 5. Select **Download on-premises agent**, and select **Accept terms & download**.

     >[!NOTE]
     >Please use different provisioning agents for on-premises application provisioning and Azure AD Connect Cloud Sync / HR-driven provisioning. All three scenarios should not be managed on the same agent. 

 6. Open the provisioning agent installer, agree to the terms of service, and select **next**.
 7. When the provisioning agent wizard opens, continue to the **Select Extension** tab and select **On-premises application provisioning** when prompted for the extension you want to enable.
 8. The provisioning agent will use the operating system's web browser to display a popup window for you to authenticate to Azure AD, and potentially also your organization's identity provider.  If you are using Internet Explorer as the browser on Windows Server, then you may need to add Microsoft web sites to your browser's trusted site list to allow JavaScript to run correctly.
 9. Provide credentials for an Azure AD administrator when you're prompted to authorize. The user is required to have the Hybrid Identity Administrator or Global Administrator role.
 10. Select **Confirm** to confirm the setting. Once installation is successful, you can select **Exit**, and also close the Provisioning Agent Package installer.

## Configure the On-premises ECMA app

 1. Sign in to the Azure portal as an administrator.
 2. Go to **Enterprise applications** and select **New application**.
 3. Search for the **On-premises ECMA app** application, give the app a name, and select **Create** to add it to your tenant.
 4. Navigate to the **Provisioning** page of your application.
 5. Select **Get started**.
 6. On the **Provisioning** page, change the mode to **Automatic**.
 7. On the **On-Premises Connectivity** section, select the agent that you just deployed and select **Assign Agent(s)**.
 8. Keep this browser window open, as you complete the next step of configuration using the configuration wizard.

  ## Configure the Azure AD ECMA Connector Host certificate

 1. On the Windows Server where the provisioning agent is installed, right click the **Microsoft ECMA2Host Configuration Wizard** from the start menu, and run as administrator.  Running as a Windows administrator is necessary for the wizard to create the necessary Windows event logs.
 2.  After the ECMA Connector Host Configuration starts, if it's the first time you have run the wizard, it will ask you to create a certificate. Leave the default port **8585** and select **Generate certificate** to generate a certificate. The autogenerated certificate will be self-signed as part of the trusted root. The certificate SAN matches the host name.
 3. Select **Save**.

 ## Create the Schema file
 Before you can use the PowerShell connector, you must first create and define a schema that the connector will use.  For this tutorial, a schema is provided.  

 1. Copy the contents of [Appendix B](#apendix-b---schemaxml) in to a text file and save it as **Schema.xml**.
 2. Put the Schema.xml file in `C:\Program Files\Microsoft ECMA2Host\Service\ECMA`.

## Create the PowerShell Connector
 1. Copy the contents of [Appendix c](#appendix-c---configuruationxml) into a text file and save it as "configuration.xml".
 2. Launch the Microsoft ECMA2Host Configuration Wizard from the start menu.

### General Screen
 1. At the top, select **Import** and select the configuration.xml file from step 1.
 2. The new connector should be created and appear in red.  Click **Edit**.
 3. Generate a secret token that will be used for authenticating Azure AD to the connector.  It should be 12 characters minimum and unique for each application.  If you do not already have a secret generator, you can use a PowerShell command such as the following to generate an example random string.
    ```powershell
    -join (((48..90) + (96..122)) * 16 | Get-Random -Count 16 | % {[char]$_})
    ```
 4. On the **Properties** page, all of the information should be populated.  The table below is provided as reference.  Click **Next**.
     
     |Property|Value|
     |-----|-----|
     |Name|The name you chose for the connector, which should be unique across all connectors in your environment. For example, `PowerShell`.|
     |Autosync timer (minutes)|120|
     |Secret Token|Enter your secret token here. It should be 12 characters minimum.|
     |Extension DLL|For the generic LDAP connector, select **Microsoft.IAM.Connector.PowerShell.dll**.|

### Connectivity
The connectivity tab allows you to supply configuration parameters for connecting to a remote system. Configure the connectivty tab with the information provided in the table below.

 1. On the **Connectivity** page, all of the information should be populated.  The table below is provided as reference.  Click **Next**.

|Parameter|Value|Purpose|
|----|-----|-----|
|  Server  | \<Blank\> | Server name that the connector should connect to.  |
|  Domain  | \<Blank\> |Domain of the credential to store for use when the connector is run.|
|User| \<Blank\> |  Username of the credential to store for use when the connector is run.  |
| Password | \<Blank\> |  Password of the credential to store for use when the connector is run.  |
| Impersonate Connector Account  |Unchecked| When true, the synchronization service runs the Windows PowerShell scripts in the context of the credentials supplied. When possible, it is recommended that the **$Credentials** parameter is passed to each script is used instead of impersonation.|
| Load User Profile When Impersonating |Unchecked|Instructs Windows to load the user profile of the connector’s credentials during impersonation. If the impersonated user has a roaming profile, the connector does not load the roaming profile.|
| Logon Type When Impersonating  |None|Logon type during impersonation. For more information, see the [dwLogonType][dw] documentation. |
|Signed Scripts Only |Unchecked|  If true, the Windows PowerShell connector validates that each script has a valid digital signature. If false, ensure that the Synchronization Service server’s Windows PowerShell execution policy is RemoteSigned or Unrestricted.| 
|Common Module Script Name (with extension)|xADSyncPSConnectorModule.psm1|The connector allows you to store a shared Windows PowerShell module in the configuration. When the connector runs a script, the Windows PowerShell module is extracted to the file system so that it can be imported by each script.|
|Common Module Script|Paste [AD Sync PS Connector Module code](https://github.com/Microsoft/MIMPowerShellConnectors/blob/master/src/FlatFileConnector/xADSyncPSConnectorModule.psm1) as value||
|Validation Script|\<Blank\>|The Validation Script is an optional Windows PowerShell script that can be used to ensure that connector configuration parameters supplied by the administrator are valid.|
|Schema Script|Paste [GetSchema code](https://github.com/Microsoft/MIMPowerShellConnectors/blob/master/src/FlatFileConnector/GetSchema.ps1) as value.||
|Additional Config Parameter Names|FileName,Delimiter,Encoding|In addition to the standard configuration settings, you can define additional custom configuration settings that are specific to the instance of the Connector. These parameters can be specified at the connector, partition, or run step levels and accessed from the relevant Windows PowerShell script. |
|Additional Encrypted Config Parameter Names|\<Blank\> ||


### Capabilities
The capabilities tab defines the behavior and functionality of the connector. The selections made on this tab cannot be modified when the connector has been created. Configure the capabilities tab with the information provided in the table below.

 1. On the **Capabilities** page, all of the information should be populated.  The table below is provided as reference.  Click **Next**. 

|Parameter|Value|Purpose|
|----|-----|-----|
|Distinguished Name Style|None|Indicates if the connector supports distinguished names and if so, what style. |
|Export Type|ObjectReplace,|Determines the type of objects that are presented to the Export script. <li>AttributeReplace – includes the full set of values for a multi-valued attribute when the attribute changes.</li><li>AttributeUpdate – includes only the deltas to a multi-valued attribute when the attribute changes.</li><li>MultivaluedReferenceAttributeUpdate - includes a full set of values for non-reference multi-valued attributes and only deltas for multi-valued reference attributes.</li><li>ObjectReplace – includes all attributes for an object when any attribute changes</li> |
|Data Normalization|None,|Instructs the Synchronization Service to normalize anchor attributes before they are provided to scripts. |
|Object Confirmation|Normal|Configures the pending import behavior in the Synchronization Service. <li>Normal – default behavior that expects all exported changes to be confirmed via import</li><li>NoDeleteConfirmation – when an object is deleted, there is no pending import generated.</li><li>NoAddAndDeleteConfirmation – when an object is created or deleted, there is no pending import generated.</li> |
|Use DN as Anchor|Unchecked|If the Distinguished Name Style is set to LDAP, the anchor attribute for the connector space is also the distinguished name. |
|Concurrent Operations of Several Connectors|Checked|When checked, multiple Windows PowerShell connectors can run simultaneously. |
|Partitions|Unchecked|When checked, the connector supports multiple partitions and partition discovery. |
|Hierarchy|Unchecked|When checked, the connector supports an LDAP style hierarchical structure. |
|Enable Import|Checked|When checked, the connector imports data via import scripts. |
|Enable Delta Import|Unchecked|When checked, the connector can request deltas from the import scripts. |
|Enable Export|Checked|When checked, the connector exports data via export scripts. |
|Enable Full Export|Checked|When checked, the export scripts support exporting the entire connector space. To use this option, Enable Export must also be checked. |
|No Reference Values In First Export Pass|Unchecked|When checked, reference attributes are exported in a second export pass. |
|Enable Object Rename|Unchecked|When checked, distinguished names can be modified. |
|Delete-Add As Replace|Checked|When checked, delete-add operations are exported as a single replacement. |
|Enable Password Operations|Unchecked|When checked, password synchronization scripts are supported. |
|Enable Export Password in First Pass|Checked|When checked, passwords set during provisioning are exported when the object is created. |


### Global Parameters
The Global Parameters tab enables you to configure the Windows PowerShell scripts that are run by the connector. You can also configure global values for custom configuration settings defined on the Connectivity tab.  Configure the global parameters tab with the information provided in the table below.

 1. On the **Global Parameters** page, all of the information should be populated.  The table below is provided as reference.  Click **Next**.

|Parameter|Value|
|-----|-----|
|Partition Script|\<Blank>|
|Hierarchy Script|\<Blank>|
|Begin Import Script|\<Blank>|
|Import Script|Paste ImportData code as value|
|End Import Script|\<Blank>|
|Begin Export Script|Paste Begin export code as value|
|Export Script|Paste ExportData code as value|
|End Export Script|\<Blank>|
|Begin Password Script|\<Blank>|
|Password Extension Script|\<Blank>|
|End Password Script|\<Blank>|
|FileName_Global|MAName_SampleInputFile.txt|
|Delimiter_Global|;|
|Encoding_Global|\<Blank> (defaults to UTF8)|

### Partitions, Run Profiles, Export, FullImport
Keep the defaults and click next.

### Object types
Configure the object types tab with the information provided in the table below.

1. On the **Object types** page, all of the information should be populated.  The table below is provided as reference.  Click **Next**.

|Parameter|Value|
|-----|-----|
|Target Object|Object|
|Anchor|EmployeeID|
|Query Attribute|EmpolyeeID|
|DN-dn-|

### Select Attributes
Ensure that the following attributes are selected:

 1. On the **Select Attributes** page, all of the information should be populated.  The table below is provided as reference.  Click **Next**.

- AzureObjectID
- IsActive
- DisplayName
- EmployeeId
- Title
- UserName
- Email


### Deprovisioning

On the Deprovisioning page, you can specify if you wish to have Azure AD remove users from the directory when they go out of scope of the application. If so, under Disable flow, select Delete, and under Delete flow, select Delete. If Set attribute value is chosen, the attributes selected on the previous page won't be available to select on the Deprovisioning page.

1. On the **Deprovisioning** page, all of the information should be populated.  The table below is provided as reference.  Click **Next**.

## Ensure ECMA2Host service is running and can read from file via PowerShell

Follow these steps to confirm that the connector host has started and has identified any existing users from the directory server.

 1. On the server running the Azure AD ECMA Connector Host, select **Start**.
 2. Select **run** if needed, then enter **services.msc** in the box.
 3. In the **Services** list, ensure that **Microsoft ECMA2Host** is present and running. If it is not running, select **Start**.
 4. On the server running the Azure AD ECMA Connector Host, launch PowerShell.
 5. Change to the folder where the ECMA host was installed, such as `C:\Program Files\Microsoft ECMA2Host`.
 6. Change to the subdirectory `Troubleshooting`.
 7. Run the script `TestECMA2HostConnection.ps1` in that directory as shown below, and provide as arguments the connector name and the `ObjectTypePath` value `cache`. If your connector host is not listening on TCP port 8585, then you may also need to provide the `-Port` argument as well. When prompted, type the secret token configured for that connector.
    ```
    PS C:\Program Files\Microsoft ECMA2Host\Troubleshooting> $cout = .\TestECMA2HostConnection.ps1 -ConnectorName PowerShell -ObjectTypePath cache; $cout.length -gt 9
    Supply values for the following parameters:
    SecretToken: ************
    ```
 8. If the script displays an error or warning message, then check that the service is running, and the connector name and secret token match those values you configured in the configuration wizard.
 9. If the script displays the output `False`, then the connector has not seen any entries in the source directory server for existing users.  If this is a new directory server installation, then this behavior is to be expected, and you can continue at the next section.
 10. However, if the directory server already contains one or more users but the script displayed `False`, then this status indicates the connector could not read from the directory server.  If you attempt to provision, then Azure AD may not correctly match users in that source directory with users in Azure AD.  Wait several minutes for the connector host to finish reading objects from the existing directory server, and then rerun the script. If the output continues to be `False`, then check the configuration of your connector and the permissions in the directory server are allowing the connector to read existing users.


## Test the connection from Azure AD to the connector host
 1. Return to the web browser window where you were configuring the application provisioning in the portal.
    >[!NOTE]
    >If the window had timed out, then you will need to re-select the agent.
     1. Sign in to the Azure portal.
     2. Go to **Enterprise applications** and the **On-premises ECMA app** application.
     3. Click on **Provisioning**.
     4. If **Get started** appears, then change the mode to **Automatic**,  on the **On-Premises Connectivity** section, select the agent that you just deployed and select **Assign Agent(s)**, and wait 10 minutes. Otherwise go to **Edit Provisioning**.
 2. Under the **Admin credentials** section, enter the following URL. Replace the `connectorName` portion with the name of the connector on the ECMA host, such as `PowerShell`. If you provided a certificate from your certificate authority for the ECMA host, then replace `localhost` with the host name of the server where the ECMA host is installed.

    |Property|Value|
    |-----|-----|
    |Tenant URL|https://localhost:8585/ecma2host_connectorName/scim|

 3. Enter the **Secret Token** value that you defined when you created the connector.
     >[!NOTE]
     >If you just assigned the agent to the application, please wait 10 minutes for the registration to complete. The connectivity test won't work until the registration completes. Forcing the agent registration to complete by restarting the provisioning agent on your server can speed up the registration process. Go to your server, search for **services** in the Windows search bar, identify the **Azure AD Connect Provisioning Agent** service, right-click the service, and restart.
 4. Select **Test Connection**, and wait one minute.
 5. After the connection test is successful and indicates that the supplied credentials are authorized to enable provisioning, select **Save**.



## Appendix A - InputFile.txt

## Apendix B - Schema.xml 
```
<?xml version="1.0" encoding="utf-8" ?>
<Schema>
  <Types>
    <SchemaType>
      <Name>Person</Name>
      <LockAnchorDefinition>1</LockAnchorDefinition>
      <Attributes>
        <SchemaAttribute>
          <Name>AzureObjectID</Name>
          <DataType>String</DataType>
          <IsAnchor>1</IsAnchor>
          <IsMultiValued>0</IsMultiValued>
          <AllowedAttributeOperation>ImportExport</AllowedAttributeOperation>
        </SchemaAttribute>
        <SchemaAttribute>
          <Name>DisplayName</Name>
          <DataType>String</DataType>
          <IsAnchor>0</IsAnchor>
          <IsMultiValued>0</IsMultiValued>
          <AllowedAttributeOperation>ImportExport</AllowedAttributeOperation>
        </SchemaAttribute>
        <SchemaAttribute>
          <Name>UserName</Name>
          <DataType>String</DataType>
          <IsAnchor>0</IsAnchor>
          <IsMultiValued>0</IsMultiValued>
          <AllowedAttributeOperation>ImportExport</AllowedAttributeOperation>
        </SchemaAttribute>
        <SchemaAttribute>
          <Name>Title</Name>
          <DataType>String</DataType>
          <IsAnchor>0</IsAnchor>
          <IsMultiValued>0</IsMultiValued>
          <AllowedAttributeOperation>ImportExport</AllowedAttributeOperation>
        </SchemaAttribute>
        <SchemaAttribute>
          <Name>EmployeeId</Name>
          <DataType>String</DataType>
          <IsAnchor>0</IsAnchor>
          <IsMultiValued>0</IsMultiValued>
          <AllowedAttributeOperation>ImportExport</AllowedAttributeOperation>
        </SchemaAttribute>
        <SchemaAttribute>
          <Name>Email</Name>
          <DataType>String</DataType>
          <IsAnchor>0</IsAnchor>
          <IsMultiValued>0</IsMultiValued>
          <AllowedAttributeOperation>ImportExport</AllowedAttributeOperation>
        </SchemaAttribute>
        <SchemaAttribute>
          <Name>IsActive</Name>
          <DataType>Boolean</DataType>
          <IsAnchor>0</IsAnchor>
          <IsMultiValued>0</IsMultiValued>
          <AllowedAttributeOperation>ImportExport</AllowedAttributeOperation>
        </SchemaAttribute>
      </Attributes>
    </SchemaType>
  </Types>
</Schema>
```
## Appendix C - Configuruation.xml 

```
<?xml version="1.0"?>
<Configuration xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <Connectors>
    <Connector>
      <ConnectorConfig>
        <Parameters>
          <Parameter>
            <Name>Server</Name>
            <Type>String</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>Domain</Name>
            <Type>String</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>User</Name>
            <Type>String</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>Password</Name>
            <Type>EncryptedString</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>true</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>Impersonate Connector Account</Name>
            <Type>CheckBox</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Load User Profile When Impersonating</Name>
            <Type>CheckBox</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Logon Type When Impersonating</Name>
            <Type>DropDown</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>None</Value>
          </Parameter>
          <Parameter>
            <Name>Signed Scripts Only</Name>
            <Type>CheckBox</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Common Module Script Name (with extension)</Name>
            <Type>String</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>xADSyncPSConnectorModule.psm1</Value>
          </Parameter>
          <Parameter>
            <Name>Common Module Script</Name>
            <Type>Text</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>
Set-PSDebug -Strict

function Enter-Script
{
  &lt;#
    .Synopsis
    Writes the Versbose message saying specified script execution started.
    .Description
    Writes the Versbose message saying specified script execution started.
    Also clear the $Error variable.
  #&gt;
  [CmdletBinding()]
  param(
    [Parameter(Mandatory = $true)]
    [string]
    $ScriptType,
    [Parameter(Mandatory = $false)]
    [ValidateNotNull()]
    [System.Collections.ArrayList]
    $ErrorObject
  )

  process
  {
    Write-Verbose "$Global:ConnectorName - $ScriptType Script: Execution Started..."
    if ($ErrorObject)
    {
      $ErrorObject.Clear()
    }
  }
}

function Exit-Script
{
  &lt;#
    .Synopsis
    Checks $Error variable for any Errors. Writes the Versbose message saying specified script execution sucessfully completed.
    .Description
    Checks $Error variable for any Errors. Writes the Versbose message saying specified script execution sucessfully completed.
    Throws an exception if $Error is present
  #&gt;
  [CmdletBinding()]
  param(
    [Parameter(Mandatory = $true)]
    [string]
    $ScriptType,
    [Parameter(Mandatory = $false)]
    [ValidateNotNull()]
    [System.Collections.ArrayList]
    $ErrorObject,
    [Parameter(Mandatory = $false)]
    [switch]
    $SuppressErrorCheck,
    [Parameter(Mandatory = $false)]
    [type]
    $ExceptionRaisedOnErrorCheck
  )

  process
  {
    if (!$SuppressErrorCheck -and $ErrorObject -and $ErrorObject.Count -ne 0)
    {
      # Take the first one otherwise you get "An error occurred while enumerating through a collection: Collection was modified; enumeration operation may not execute.."
      # Seems like a bug in Remote PSH
      $errorMessage = $ErrorObject[0] # | Out-String -ErrorAction SilentlyContinue

      if ($ExceptionRaisedOnErrorCheck -eq $null)
      {
        $ExceptionRaisedOnErrorCheck = [Microsoft.MetadirectoryServices.ExtensibleExtensionException]
      }

      $ErrorObject.Clear()

      throw $errorMessage -as $ExceptionRaisedOnErrorCheck
    }

    Write-Verbose "$Global:ConnectorName - $ScriptType Script: Execution Completed."
  }
}

function Get-ExtensionsDirectory
{
  &lt;#
    .Synopsis
    Gets the path of the "Extensions" folder.
    .Description
    Gets the path of the "Extensions" folder.
  #&gt;
  [CmdletBinding()]
  [OutputType([string])]
  param(
  )

  process
  {
    $scriptDir = "C:\\Program Files\\Microsoft ECMA2Host\\Service\\ECMA"

    return $scriptDir
  }
}

function ConvertFrom-SchemaXml
{
    &lt;#
    .Synopsis
    Converts a connector schema defined in a xml file into a "Microsoft.MetadirectoryServices.Schema" object.
    .Description
    Converts a connector schema defined in a xml file into a "Microsoft.MetadirectoryServices.Schema" object.
    .Example
    ConvertFrom-SchemaXml -SchemaXml "Schema.xml"
    #&gt;  

  [CmdletBinding()]
  [OutputType([Microsoft.MetadirectoryServices.Schema])]
  param(
    [Parameter(Mandatory = $true)]
    [ValidateScript({ Test-Path $_ -PathType "Leaf" })]
    [string]
    $SchemaXml
  )

  process
  {
    $x = [xml](Get-Content $SchemaXml)

    $schema = [Microsoft.MetadirectoryServices.Schema]::Create()

    foreach ($t in $x.Schema.Types.SchemaType)
    {
      $lockAnchorDefinition = $true

      if ($t.LockAnchorDefinition -eq "0")
      {
        $lockAnchorDefinition = $false
      }

      $schemaType = [Microsoft.MetadirectoryServices.SchemaType]::Create($t.Name,$lockAnchorDefinition)

      if ($t.GetElementsByTagName("PossibleDNComponentsForProvisioning").Count -gt 0)
      {
        foreach ($c in $t.PossibleDNComponentsForProvisioning)
        {
          $schemaType.PossibleDNComponentsForProvisioning.Add($c)
        }
      }

      foreach ($a in $t.Attributes.SchemaAttribute)
      {
        if ($a.IsAnchor -eq 1)
        {
          $schemaType.Attributes.Add([Microsoft.MetadirectoryServices.SchemaAttribute]::CreateAnchorAttribute($a.Name,$a.DataType,$a.AllowedAttributeOperation))
        }
        elseif ($a.IsMultiValued -eq 1)
        {
          $schemaType.Attributes.Add([Microsoft.MetadirectoryServices.SchemaAttribute]::CreateMultiValuedAttribute($a.Name,$a.DataType,$a.AllowedAttributeOperation))
        }
        else
        {
          $schemaType.Attributes.Add([Microsoft.MetadirectoryServices.SchemaAttribute]::CreateSingleValuedAttribute($a.Name,$a.DataType,$a.AllowedAttributeOperation))
        }
      }

      $schema.Types.Add($schemaType)
    }

    return $schema
  }
}


function Get-xADSyncPSConnectorSetting
{
  [CmdletBinding()]
  param(
    [Parameter(Mandatory = $true)]
    [ValidateNotNull()]
    [Alias('InputObject')]
    [System.Collections.ObjectModel.KeyedCollection[string, Microsoft.MetadirectoryServices.ConfigParameter]]
    $ConfigurationParameters,
    [Parameter(Mandatory = $true)]
    [ValidateNotNullOrEmpty()]
    [string]
    $Name,
    [Parameter(Mandatory = $true)]
    [ValidateSet('Global','Partition','RunStep')]
    [string]
    $Scope,
    $DefaultValue
  )
  process
  {
    try
    {
      $scopedName = '{0}_{1}' -f $Name,$Scope

      if ($ConfigurationParameters[$scopedName].Value)
      {
        return $ConfigurationParameters[$scopedName].Value
      }
      elseif ($PSBoundParameters.ContainsKey('DefaultValue'))
      {
        return $DefaultValue
      }
      else
      {
        return $null
      }
    }
    catch [System.Collections.Generic.KeyNotFoundException]
    {
      # if they gave us a default, go ahead and return it
      if ($PSBoundParameters.ContainsKey('DefaultValue'))
      {
        return $DefaultValue
      }
      else
      {
        throw
      }
    }
  }
}

function Get-xADSyncPSConnectorFolder
{
  [CmdletBinding()]
  [OutputType([string])]
  param(
    [Parameter(Mandatory = $true,Position = 0)]
    [ValidateSet('ManagementAgent','Extensions')]
    [string]
    $Folder
  )

  switch ($Folder)
  {
    'ManagementAgent'
    {
      return [Microsoft.MetadirectoryServices.MAUtils]::MAFolder
    }
    'Extensions'
    {
      return [Microsoft.MetadirectoryServices.Utils]::ExtensionsDirectory
    }
    default
    {
      throw "Folder '$Folder' is not supported"
    }
  }
}

#region Schema Helpers
function New-xADSyncPSConnectorSchema
{
  [CmdletBinding()]
  [OutputType([Microsoft.MetadirectoryServices.Schema])]
  param()

  return [Microsoft.MetadirectoryServices.Schema]::Create()
}

function New-xADSyncPSConnectorSchemaType
{
  [CmdletBinding()]
  [OutputType([Microsoft.MetadirectoryServices.SchemaType])]
  param(
    [ValidateNotNullOrEmpty()]
    [string]
    $Name,
    [switch]
    $LockAnchorAttributeDefinition
  )

  return [Microsoft.MetadirectoryServices.SchemaType]::Create($Name,$LockAnchorAttributeDefinition.ToBool())
}

function Add-xADSyncPSConnectorSchemaAttribute
{
  [CmdletBinding(DefaultParameterSetName = 'Singlevalued')]
  param(
    [Parameter(Mandatory = $true,ValueFromPipeline = $true)]
    [Microsoft.MetadirectoryServices.SchemaType]
    [ValidateNotNull()]
    $InputObject,
    [ValidateNotNullOrEmpty()]
    [string]
    [Parameter(Mandatory = $true,ParameterSetName = 'Anchor')]
    [Parameter(Mandatory = $true,ParameterSetName = 'Multivalued')]
    [Parameter(Mandatory = $true,ParameterSetName = 'Singlevalued')]
    $Name,
    [Parameter(ParameterSetName = 'Anchor')]
    [switch]
    $Anchor,
    [Parameter(ParameterSetName = 'Multivalued')]
    [switch]
    $Multivalued,
    [Parameter(Mandatory = $true,ParameterSetName = 'Anchor')]
    [Parameter(Mandatory = $true,ParameterSetName = 'Multivalued')]
    [Parameter(Mandatory = $true,ParameterSetName = 'Singlevalued')]
    [ValidateSet('Binary','Boolean','Integer','Reference','String')]
    [string]
    $DataType,
    [Parameter(Mandatory = $true,ParameterSetName = 'Anchor')]
    [Parameter(Mandatory = $true,ParameterSetName = 'Multivalued')]
    [Parameter(Mandatory = $true,ParameterSetName = 'Singlevalued')]
    [ValidateSet('ImportOnly','ExportOnly','ImportExport')]
    [string]
    $SupportedOperation
  )

  process
  {
    switch ($PSCmdlet.ParameterSetName)
    {
      'Singlevalued'
      {
        $InputObject.Attributes.Add([Microsoft.MetadirectoryServices.SchemaAttribute]::CreateSingleValuedAttribute($Name,$DataType,$SupportedOperation))
      }
      'Multivalued'
      {
        if ($Multivalued.ToBool() -eq $true)
        {
          $InputObject.Attributes.Add([Microsoft.MetadirectoryServices.SchemaAttribute]::CreateMultiValuedAttribute($Name,$DataType,$SupportedOperation))
        }
        else
        {
          $InputObject.Attributes.Add([Microsoft.MetadirectoryServices.SchemaAttribute]::CreateSingleValuedAttribute($Name,$DataType,$SupportedOperation))
        }
      }
      'Anchor'
      {
        if ($Anchor.ToBool() -eq $true)
        {
          $InputObject.Attributes.Add([Microsoft.MetadirectoryServices.SchemaAttribute]::CreateAnchorAttribute($Name,$DataType,$SupportedOperation))
        }
        else
        {
          $InputObject.Attributes.Add([Microsoft.MetadirectoryServices.SchemaAttribute]::CreateSingleValuedAttribute($Name,$DataType,$SupportedOperation))
        }
      }
      default
      {
        throw "Parameter set '$($PSCmdlet.ParameterSetName)' is not supported"
      }
    }
  }
}
#endregion

#region Partition Helpers
function New-FIMPSConnectorPartition
{
  [CmdletBinding()]
  [OutputType([Microsoft.MetaDirectoryServices.Partition])]
  param(
    [Parameter(Mandatory = $true)]
    [guid]
    $Identifier,
    [Parameter(Mandatory = $true)]
    [ValidateNotNullOrEmpty()]
    [string]
    $DistinguishedName,
    [Parameter(Mandatory = $false)]
    [ValidateNotNullOrEmpty()]
    [string]
    $DisplayName
  )

  if ($PSBoundParameters.ContainsKey('DisplayName'))
  {
    return [Microsoft.MetadirectoryServices.Partition]::Create($Identifier,$DistinguishedName,$DisplayName)
  }
  else
  {
    return [Microsoft.MetadirectoryServices.Partition]::Create($Identifier,$DistinguishedName)
  }
}
#endregion
function New-xADSyncPSConnectorHierarchyNode
{
  [CmdletBinding()]
  [OutputType([Microsoft.MetadirectoryServices.HierarchyNode])]
  param(
    [Parameter(Mandatory = $true)]
    [ValidateNotNullOrEmpty()]
    [string]
    $DistinguishedName,
    [Parameter(Mandatory = $true)]
    [ValidateNotNullOrEmpty()]
    [string]
    $DisplayName
  )

  return [Microsoft.MetadirectoryServices.HierarchyNode]::Create($DistinguishedName,$DisplayName)
}
#region Hierarchy Helpers

#endregion

#region Import Helpers
function New-xADSyncPSConnectorCSEntryChange
{
  [CmdletBinding()]
  [OutputType([Microsoft.MetadirectoryServices.CSEntryChange])]
  param(
    [Parameter(Mandatory = $true)]
    [ValidateNotNullOrEmpty()]
    [string]
    $ObjectType,
    [Parameter(Mandatory = $true)]
    [ValidateSet('Add','Delete','Update','Replace','None')]
    [string]
    $ModificationType,
    [ValidateNotNullOrEmpty()]
    [Alias('DistinguishedName')]
    [string]
    $DN,
    [ValidateNotNullOrEmpty()]
    [Alias('RelativeDistinguishedName')]
    [string]
    $RDN
  )

  $csEntry = [Microsoft.MetadirectoryServices.CSEntryChange]::Create()
  $csEntry.ObjectModificationType = $ModificationType
  $csEntry.ObjectType = $ObjectType

  if ($PSBoundParameters.ContainsKey('DN'))
  {
    $csEntry.DN = $DN
  }

  if ($PSBoundParameters.ContainsKey('RDN'))
  {
    $csEntry.RDN = $RDN
  }

  Write-Output $csEntry
}

function Add-xADSyncPSConnectorCSAttribute
{
  [CmdletBinding()]
  param(
    [Parameter(Mandatory = $true,ValueFromPipeline = $true)]
    [Microsoft.MetadirectoryServices.CSEntryChange]
    [ValidateNotNull()]
    $InputObject,
    [Parameter(Mandatory = $true)]
    [ValidateSet('Add','Update','Delete','Replace','Rename')]
    [string]
    $ModificationType,
    [ValidateNotNullOrEmpty()]
    [string]
    $Name,
    $Value
  )

  process
  {
    if ($ModificationType -ne 'Rename' -and $Name -eq $null)
    {
      throw 'Name parameter is required'
    }

    if ($ModificationType -ne 'Delete' -and $Value -eq $null)
    {
      throw 'Value parameter is required'
    }

    switch ($ModificationType)
    {
      'Add'
      {
        $InputObject.AttributeChanges.Add([Microsoft.MetadirectoryServices.AttributeChange]::CreateAttributeAdd($Name,$Value))
      }
      'Update'
      {
        $InputObject.AttributeChanges.Add([Microsoft.MetadirectoryServices.AttributeChange]::CreateAttributeUpdate($Name,$Value))
      }
      'Delete'
      {
        $InputObject.AttributeChanges.Add([Microsoft.MetadirectoryServices.AttributeChange]::CreateAttributeDelete($Name))
      }
      'Replace'
      {
        $InputObject.AttributeChanges.Add([Microsoft.MetadirectoryServices.AttributeChange]::CreateAttributeReplace($Name,$Value))
      }
      'Rename'
      {
        $InputObject.AttributeChanges.Add([Microsoft.MetadirectoryServices.AttributeChange]::CreateNewDN($Value))
      }
      default
      {
        throw "Modification type $ModificationType is not supported"
      }
    }
  }
}
#endregion

function New-GenericObject
{
  [CmdletBinding()]
  param(
    [Parameter(Mandatory = $true)]
    [ValidateNotNullOrEmpty()]
    [string]
    $TypeName,
    [Parameter(Mandatory = $true)]
    [ValidateNotNullOrEmpty()]
    [string[]]
    $TypeParameters,
    [Parameter(Mandatory = $false)]
    [object[]]
    $ConstructorParameters
  )

  $genericTypeName = $typeName + '
              `r`n' + $typeParameters.Count
  $genericType = [type]$genericTypeName

  if (!$genericType)
  {
    throw "Could not find generic type $genericTypeName"
  }

  ## Bind the type arguments to it
  $typedParameters = [Type[]]$typeParameters
  $closedType = $genericType.MakeGenericType($typedParameters)

  if (!$closedType)
  {
    throw "Could not make closed type $genericType"
  }

  ## Create the closed version of the generic type. Don't forget comma prefix
  ,[Activator]::CreateInstance($closedType,$constructorParameters)
}

Export-ModuleMember -Function * -Verbose:$false -Debug:$false</Value>
          </Parameter>
          <Parameter>
            <Name>Validation Script</Name>
            <Type>Text</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>Schema Script</Name>
            <Type>Text</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>[CmdletBinding()]
param(
  [Parameter(Mandatory = $true)]
  [System.Collections.ObjectModel.KeyedCollection[string,Microsoft.MetadirectoryServices.ConfigParameter]]
  $ConfigParameters,
  [Parameter(Mandatory = $false)]
  [Alias('PSCredential')] # To fix mess-up of the parameter name in the RTM version of the PowerShell connector.
  [System.Management.Automation.PSCredential]
  $Credential,
  [Parameter(Mandatory = $false)]
  [ValidateScript({ Test-Path $_ -PathType "Container" })]
  [string]
  $ScriptDir = (Join-Path -Path $env:windir -ChildPath "TEMP") # Optional parameter for manipulation by the TestHarness script.
)

Set-StrictMode -Version "2.0"

$Global:DebugPreference = "Continue"
$Global:VerbosePreference = "Continue"

$commonModule = (Join-Path -Path ([System.Environment]::GetEnvironmentVariable('Temp', 'Machine')) -ChildPath $ConfigParameters["Common Module Script Name (with extension)"].Value)

if (!(Get-Module -Name (Get-Item $commonModule).BaseName)) { Import-Module -Name $commonModule }

Enter-Script -ScriptType "Schema" -ErrorObject $Error

function Get-ConnectorSchema
{
&lt;#
    .Synopsis
    Gets the connector space schema.
    .Description
    Gets the connector space schema defined in the "Schema.xml" file.
#&gt;

  [CmdletBinding()]
  [OutputType([Microsoft.MetadirectoryServices.Schema])]
  param(
  )

  $extensionsDir = Get-ExtensionsDirectory
  $schemaXml = Join-Path -Path $extensionsDir -ChildPath "Schema.xml"

  $schema = ConvertFrom-SchemaXml -SchemaXml $schemaXml

  return $schema
}

Get-ConnectorSchema

Exit-Script -ScriptType "Schema" -ErrorObject $Error</Value>
          </Parameter>
          <Parameter>
            <Name>Additional Config Parameter Names</Name>
            <Type>String</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>FileName,Delimiter,Encoding</Value>
          </Parameter>
          <Parameter>
            <Name>Additional Encrypted Config Parameter Names</Name>
            <Type>String</Type>
            <Use>Connectivity</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>Distinguished Name Style</Name>
            <Type>DropDown</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>None</Value>
          </Parameter>
          <Parameter>
            <Name>Export Type</Name>
            <Type>DropDown</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>ObjectReplace</Value>
          </Parameter>
          <Parameter>
            <Name>Data Normalization</Name>
            <Type>DropDown</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>None</Value>
          </Parameter>
          <Parameter>
            <Name>Object Confirmation</Name>
            <Type>DropDown</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>Normal</Value>
          </Parameter>
          <Parameter>
            <Name>Use DN As Anchor (Only LDAP style DN)</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Concurrent Operations Of Several Connectors</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>1</Value>
          </Parameter>
          <Parameter>
            <Name>Partitions (Only LDAP style DN)</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Hierarchy (Only LDAP style DN)</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Enable Import</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>1</Value>
          </Parameter>
          <Parameter>
            <Name>Enable Delta Import</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Enable Export</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>1</Value>
          </Parameter>
          <Parameter>
            <Name>Enable Full Export</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>No Reference Values In First Export Pass</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Enable Object Rename</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Delete-Add As Replace</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Enable Password operations</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Enable Export Password In First Pass</Name>
            <Type>CheckBox</Type>
            <Use>Capabilities</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>Partition Script</Name>
            <Type>Text</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>Hierarchy Script</Name>
            <Type>Text</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>Begin Import Script</Name>
            <Type>Text</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>Import Script</Name>
            <Type>Text</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>param(
  [System.Collections.ObjectModel.KeyedCollection[string, Microsoft.MetadirectoryServices.ConfigParameter]]

  [ValidateNotNull()]

  $ConfigParameters,

  [Microsoft.MetadirectoryServices.Schema]

  [ValidateNotNull()]

  $Schema,

  [Microsoft.MetadirectoryServices.OpenImportConnectionRunStep]

  $OpenImportConnectionRunStep,

  [Microsoft.MetadirectoryServices.ImportRunStep]

  $GetImportEntriesRunStep,

  [pscredential]

  $PSCredential

)

Set-PSDebug -Strict

$commonModule = (Join-Path -Path ([Microsoft.MetadirectoryServices.MAUtils]::MAFolder) -ChildPath $ConfigParameters['Common Module Script Name (with extension)'].Value)
Import-Module -Name $commonModule -Verbose:$false -ErrorAction Stop

$importResults = New-Object -TypeName 'Microsoft.MetadirectoryServices.GetImportEntriesResults'

$csEntries = New-Object -TypeName 'System.Collections.Generic.List[Microsoft.MetadirectoryServices.CSEntryChange]'

$columnsToImport = $Schema.Types[0].Attributes

Write-Verbose "Loaded $($columnsToImport.Count) attributes to import"

$importCsvParameters = @{

  Path = (Join-Path -Path (Get-xADSyncPSConnectorFolder -Folder ManagementAgent) -ChildPath (Get-xADSyncPSConnectorSetting -Name 'FileName' -Scope Global -ConfigurationParameters $ConfigParameters))

}

if ((Test-Path $importCsvParameters['Path'] -PathType Leaf) -eq $false)

{

  ##TODO: ECMA exception?

  throw "Could not find $($importCsvParameters['Path'])"

}

Write-Verbose "Import path: $($importCsvParameters['Path'])"

$delimiter = Get-xADSyncPSConnectorSetting -Name 'Delimiter' -Scope Global -ConfigurationParameters $ConfigParameters

if ($delimiter)

{

  $importCsvParameters.Add('Delimiter',$delimiter)

  Write-Verbose "Setting delimiter to $delimiter)"

}

$encoding = Get-xADSyncPSConnectorSetting -Name 'Encoding' -Scope Global -ConfigurationParameters $ConfigParameters

if ($encoding)

{

  ##TODO: Validation

  $importCsvParameters.Add('Encoding',$encoding)

  Write-Verbose "Setting encoding to $encoding)"

}

$recordsToImport = Import-Csv @importCsvParameters

Write-Verbose "Imported $($recordsToImport.Count) records"

foreach ($record in $recordsToImport)

{

  Write-Verbose 'Starting new record'

  ##TODO: Handle a missing anchor (what exception to throw?)

  $foundValidColumns = $false

  $entrySchema = $Schema.Types[0];
  $csEntry = New-xADSyncPSConnectorCSEntryChange -ObjectType $entrySchema.Name -ModificationType Add

  foreach ($column in $columnsToImport)

  {

    $columnName = $column.Name

    Write-Verbose "Processing column $columnName"

    if ($record.$columnName)

    {

      Write-Verbose 'Found column'

      $foundValidColumns = $true

      ##TODO: Support multivalue?

      $anchorAttrName = $entrySchema.AnchorAttributes[0].Name
      $value = [string]$record.$columnName

      Write-Verbose "$columnName with value equal $value"


      if ($columnName -eq $anchorAttrName)
      {


        $csEntry.AnchorAttributes.Add([Microsoft.MetadirectoryServices.AnchorAttribute]::Create($columnName,$value))
      }


      $csEntry | Add-xADSyncPSConnectorCSAttribute -ModificationType Add -Name $columnName -Value ([Collections.IList]($record.$columnName.Split(";")))

    }

  }

  if ($foundValidColumns)

  {

    Write-Verbose 'Publishing CSEntryChange'

    $csEntries.Add($csEntry)

  }

  Write-Verbose 'Record completed'

}

##TODO: Support paging

$importResults.CSEntries = $csEntries

$importResults.MoreToImport = $false

Write-Output $importResults</Value>
          </Parameter>
          <Parameter>
            <Name>End Import Script</Name>
            <Type>Text</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>Begin Export Script</Name>
            <Type>Text</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>Export Script</Name>
            <Type>Text</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>
param(
  [System.Collections.ObjectModel.KeyedCollection[string, Microsoft.MetadirectoryServices.ConfigParameter]]

  $ConfigParameters,

  [Microsoft.MetadirectoryServices.Schema]

  $Schema,

  [Microsoft.MetadirectoryServices.OpenExportConnectionRunStep]

  $OpenExportConnectionRunStep,

  [System.Collections.Generic.IList[Microsoft.MetaDirectoryServices.CSEntryChange]]

  $CSEntries,

  [pscredential]

  $PSCredential

)

Set-PSDebug -Strict


$commonModule = (Join-Path -Path ([Microsoft.MetadirectoryServices.MAUtils]::MAFolder) -ChildPath $ConfigParameters['Common Module Script Name (with extension)'].Value)
Import-Module -Name $commonModule -Verbose:$false -ErrorAction Stop

function CreateCustomPSObject

{

  param

  (

    $PropertyNames = @()

  )

  $template = New-Object -TypeName System.Object

  foreach ($property in $PropertyNames)

  {

    $template | Add-Member -MemberType NoteProperty -Name $property -Value $null

  }

  return $template
}


function DeleteFromCsv
{
  param($CsvParameters,[string]$ColumnName,[string]$ColumnValue)

  try
  {
    Write-Verbose "Delete from CSV. File: $($CsvParameters.Path)"

    $csv = Import-Csv -Path $CsvParameters.Path -Delimiter $CsvParameters.Delimiter | Where-Object $ColumnName -NE $ColumnValue

    Write-Verbose "New csv: $($csv)"

    $csv | Export-Csv -Path $CsvParameters.Path -Delimiter $CsvParameters.Delimiter -NoTypeInformation
  }
  catch
  {
    Write-Error $_.ErrorDetails.Message
  }
}

$exportCsvParameters = @{

  Path = (Join-Path -Path (Get-xADSyncPSConnectorFolder -Folder ManagementAgent) -ChildPath (Get-xADSyncPSConnectorSetting -Name 'FileName' -Scope Global -ConfigurationParameters $ConfigParameters))

}



$csentryChangeResults = New-Object "System.Collections.Generic.List[Microsoft.MetadirectoryServices.CSEntryChangeResult]"

if ((Test-Path ([IO.Path]::GetDirectoryName($exportCsvParameters['Path'])) -PathType Container) -eq $false)

{

  ##TODO: ECMA exception?

  throw "Could not find $($exportCsvParameters['Path'])"

}

Write-Verbose "Export path: $($exportCsvParameters['Path'])"

$delimiter = Get-xADSyncPSConnectorSetting -Name 'Delimiter' -Scope Global -ConfigurationParameters $ConfigParameters

if ($delimiter)

{

  $exportCsvParameters.Add('Delimiter',$delimiter)

  Write-Verbose "Setting delimiter to $delimiter)"

}

$encoding = Get-xADSyncPSConnectorSetting -Name 'Encoding' -Scope Global -ConfigurationParameters $ConfigParameters

if ($encoding)

{

  ##TODO: Validation

  $exportCsvParameters.Add('Encoding',$encoding)

  Write-Verbose "Setting encoding to $encoding)"

}

$columnsToExport = @()

foreach ($attribute in $Schema.Types[0].Attributes)

{

  $columnsToExport += $attribute.Name

  Write-Verbose "Added attribute $($attribute.Name) to export list"

}



$csvSource = @()

Write-Verbose "Processing object $($entry.Identifier)"


foreach ($entry in $CSEntries)

{

  Write-Verbose "Processing object $($entry.Identifier). ObjectModificationType $($entry.ObjectModificationType)"

  [bool]$objectHasAttributes = $false

  $baseObject = CreateCustomPSObject -PropertyNames $columnsToExport

  if ($entry.ObjectModificationType -eq 'Replace')
  {
    $anchorAttributeName = $entry.AnchorAttributes[0].Name;
    $anchorAttributeValue = $entry.AnchorAttributes[0].Value.ToString();
    Write-Verbose "Remove the object with attribute '$($anchorAttributeName)' equals '$($anchorAttributeValue)' before replacing it with new object"
    DeleteFromCsv -CsvParameters $exportCsvParameters -ColumnName $anchorAttributeName -ColumnValue $anchorAttributeValue
  }


  if ($entry.ObjectModificationType -ne 'Delete')

  {

    foreach ($attribute in $columnsToExport)

    {

      if (($entry.AttributeChanges.Contains($attribute)) -eq $false -and ($entry.AnchorAttributes.Contains($attribute) -eq $false))

      {

        continue

      }


      if ($entry.AnchorAttributes[$attribute].Value)

      {

        $baseObject.$attribute = $entry.AnchorAttributes[$attribute].Value

        $objectHasAttributes = $true

      }

      elseif ($entry.AttributeChanges[$attribute].ValueChanges[0].Value)

      {

        $baseObject.$attribute = ($entry.AttributeChanges[$attribute].ValueChanges | Select-Object -Expand Value) -join ";"

        $objectHasAttributes = $true

      }

    }

    if ($objectHasAttributes)

    {

      $csvSource += $baseObject

    }


  }
  else
  {
    $anchorAttributeName = $entry.AnchorAttributes[0].Name;
    $anchorAttributeValue = $entry.AnchorAttributes[0].Value.ToString();
    Write-Verbose "Delete the object with attribute '$($anchorAttributeName)' equals '$($anchorAttributeValue)'"
    DeleteFromCsv -CsvParameters $exportCsvParameters -ColumnName $anchorAttributeName -ColumnValue $anchorAttributeValue
  }

  $csentryChangeResult = [Microsoft.MetadirectoryServices.CSEntryChangeResult]::Create($entry.Identifier,$null,"Success")
  $csentryChangeResults.Add($csentryChangeResult)

  Write-Verbose "Completed processing object $($entry.Identifier)"

}

$csvSource | Export-Csv @exportCsvParameters -NoTypeInformation -Append -Force

$closedType = [type]"Microsoft.MetadirectoryServices.PutExportEntriesResults"

return [Activator]::CreateInstance($closedType,$csentryChangeResults)</Value>
          </Parameter>
          <Parameter>
            <Name>End Export Script</Name>
            <Type>Text</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>Begin Password Script</Name>
            <Type>Text</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>Password Extension Script</Name>
            <Type>Text</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>End Password Script</Name>
            <Type>Text</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>PowerShell script execution timeout in minutes (0 – disabled)</Name>
            <Type>String</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>0</Value>
          </Parameter>
          <Parameter>
            <Name>FileName_Global</Name>
            <Type>String</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>InputFile.txt</Value>
          </Parameter>
          <Parameter>
            <Name>Delimiter_Global</Name>
            <Type>String</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>;</Value>
          </Parameter>
          <Parameter>
            <Name>Encoding_Global</Name>
            <Type>String</Type>
            <Use>Global</Use>
            <SchemaNumber>1</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>FileName_RunStep</Name>
            <Type>String</Type>
            <Use>RunStep</Use>
            <SchemaNumber>0</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>InputFile.txt</Value>
          </Parameter>
          <Parameter>
            <Name>Delimiter_RunStep</Name>
            <Type>String</Type>
            <Use>RunStep</Use>
            <SchemaNumber>0</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>;</Value>
          </Parameter>
          <Parameter>
            <Name>Encoding_RunStep</Name>
            <Type>String</Type>
            <Use>RunStep</Use>
            <SchemaNumber>0</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value />
          </Parameter>
          <Parameter>
            <Name>PageSizeFullImport</Name>
            <Type>Text</Type>
            <Use>RunStep</Use>
            <SchemaNumber>0</SchemaNumber>
            <Encrypted>false</Encrypted>
            <Value>5000</Value>
          </Parameter>
        </Parameters>
        <RunConfigurations>
          <RunConfiguration>
            <Id>9fd4ccfc-55b6-4e3a-a9ac-ef2f451018e7</Id>
            <Name>Export</Name>
            <VersionNumber>0</VersionNumber>
            <CreationTime>2023-04-27T21:33:19.2865423-07:00</CreationTime>
            <LastModificationTime>2023-04-27T21:33:19.2865423-07:00</LastModificationTime>
            <RunSteps>
              <RunStep>
                <Name>Export</Name>
                <Type>None</Type>
                <Partition>default</Partition>
                <BatchSize>0</BatchSize>
                <Timeout>0</Timeout>
                <Parameters>
                  <Parameter>
                    <Name>FileName_RunStep</Name>
                    <Type>String</Type>
                    <Use>RunStep</Use>
                    <SchemaNumber>0</SchemaNumber>
                    <Encrypted>false</Encrypted>
                    <Value>InputFile.txt</Value>
                  </Parameter>
                  <Parameter>
                    <Name>Delimiter_RunStep</Name>
                    <Type>String</Type>
                    <Use>RunStep</Use>
                    <SchemaNumber>0</SchemaNumber>
                    <Encrypted>false</Encrypted>
                    <Value>;</Value>
                  </Parameter>
                  <Parameter>
                    <Name>Encoding_RunStep</Name>
                    <Type>String</Type>
                    <Use>RunStep</Use>
                    <SchemaNumber>0</SchemaNumber>
                    <Encrypted>false</Encrypted>
                    <Value />
                  </Parameter>
                  <Parameter>
                    <Name>PageSizeExport</Name>
                    <Type>Text</Type>
                    <Use>RunStep</Use>
                    <SchemaNumber>0</SchemaNumber>
                    <Encrypted>false</Encrypted>
                    <Value>5000</Value>
                  </Parameter>
                </Parameters>
              </RunStep>
            </RunSteps>
          </RunConfiguration>
          <RunConfiguration>
            <Id>4587911e-9173-4324-98fd-a8e6207bae33</Id>
            <Name>FullImport</Name>
            <VersionNumber>0</VersionNumber>
            <CreationTime>2023-04-27T21:33:46.7386769-07:00</CreationTime>
            <LastModificationTime>2023-04-27T21:33:46.7386769-07:00</LastModificationTime>
            <RunSteps>
              <RunStep>
                <Name>Import</Name>
                <Type>None</Type>
                <Partition>default</Partition>
                <BatchSize>0</BatchSize>
                <Timeout>0</Timeout>
                <Parameters>
                  <Parameter>
                    <Name>FileName_RunStep</Name>
                    <Type>String</Type>
                    <Use>RunStep</Use>
                    <SchemaNumber>0</SchemaNumber>
                    <Encrypted>false</Encrypted>
                    <Value>InputFile.txt</Value>
                  </Parameter>
                  <Parameter>
                    <Name>Delimiter_RunStep</Name>
                    <Type>String</Type>
                    <Use>RunStep</Use>
                    <SchemaNumber>0</SchemaNumber>
                    <Encrypted>false</Encrypted>
                    <Value>;</Value>
                  </Parameter>
                  <Parameter>
                    <Name>Encoding_RunStep</Name>
                    <Type>String</Type>
                    <Use>RunStep</Use>
                    <SchemaNumber>0</SchemaNumber>
                    <Encrypted>false</Encrypted>
                    <Value />
                  </Parameter>
                  <Parameter>
                    <Name>PageSizeFullImport</Name>
                    <Type>Text</Type>
                    <Use>RunStep</Use>
                    <SchemaNumber>0</SchemaNumber>
                    <Encrypted>false</Encrypted>
                    <Value>5000</Value>
                  </Parameter>
                </Parameters>
              </RunStep>
            </RunSteps>
          </RunConfiguration>
        </RunConfigurations>
        <IsExportSupported>true</IsExportSupported>
        <IsFullImportSupported>true</IsFullImportSupported>
        <IsDeltaImportSupported>false</IsDeltaImportSupported>
        <IsExportOnly>false</IsExportOnly>
      </ConnectorConfig>
      <Schema>
        <EntriesSchema>
          <EntrySchema>
            <ExternalName>User</ExternalName>
            <ObjectType>Person</ObjectType>
            <SchemaAttributes>
              <AttributeSchema>
                <Name>AzureObjectID</Name>
                <IsAnchor>true</IsAnchor>
                <IsDN>true</IsDN>
                <IsQueryAttribute>true</IsQueryAttribute>
                <IsDeprovisioningAttribute>false</IsDeprovisioningAttribute>
                <Multivalued>false</Multivalued>
                <TreatAsSingleValue>false</TreatAsSingleValue>
                <DataType>String</DataType>
              </AttributeSchema>
              <AttributeSchema>
                <Name>DisplayName</Name>
                <IsAnchor>false</IsAnchor>
                <IsDN>false</IsDN>
                <IsQueryAttribute>false</IsQueryAttribute>
                <IsDeprovisioningAttribute>false</IsDeprovisioningAttribute>
                <Multivalued>false</Multivalued>
                <TreatAsSingleValue>false</TreatAsSingleValue>
                <DataType>String</DataType>
              </AttributeSchema>
              <AttributeSchema>
                <Name>Email</Name>
                <IsAnchor>false</IsAnchor>
                <IsDN>false</IsDN>
                <IsQueryAttribute>false</IsQueryAttribute>
                <IsDeprovisioningAttribute>false</IsDeprovisioningAttribute>
                <Multivalued>false</Multivalued>
                <TreatAsSingleValue>false</TreatAsSingleValue>
                <DataType>String</DataType>
              </AttributeSchema>
              <AttributeSchema>
                <Name>EmployeeId</Name>
                <IsAnchor>false</IsAnchor>
                <IsDN>false</IsDN>
                <IsQueryAttribute>false</IsQueryAttribute>
                <IsDeprovisioningAttribute>false</IsDeprovisioningAttribute>
                <Multivalued>false</Multivalued>
                <TreatAsSingleValue>false</TreatAsSingleValue>
                <DataType>String</DataType>
              </AttributeSchema>
              <AttributeSchema>
                <Name>IsActive</Name>
                <IsAnchor>false</IsAnchor>
                <IsDN>false</IsDN>
                <IsQueryAttribute>false</IsQueryAttribute>
                <IsDeprovisioningAttribute>false</IsDeprovisioningAttribute>
                <Multivalued>false</Multivalued>
                <TreatAsSingleValue>false</TreatAsSingleValue>
                <DataType>Boolean</DataType>
              </AttributeSchema>
              <AttributeSchema>
                <Name>Title</Name>
                <IsAnchor>false</IsAnchor>
                <IsDN>false</IsDN>
                <IsQueryAttribute>false</IsQueryAttribute>
                <IsDeprovisioningAttribute>false</IsDeprovisioningAttribute>
                <Multivalued>false</Multivalued>
                <TreatAsSingleValue>false</TreatAsSingleValue>
                <DataType>String</DataType>
              </AttributeSchema>
              <AttributeSchema>
                <Name>UserName</Name>
                <IsAnchor>false</IsAnchor>
                <IsDN>false</IsDN>
                <IsQueryAttribute>false</IsQueryAttribute>
                <IsDeprovisioningAttribute>false</IsDeprovisioningAttribute>
                <Multivalued>false</Multivalued>
                <TreatAsSingleValue>false</TreatAsSingleValue>
                <DataType>String</DataType>
              </AttributeSchema>
            </SchemaAttributes>
            <IsDNAutogenerated>false</IsDNAutogenerated>
            <DeprovisioningModel>
              <HardDeleteStatusAttribute />
              <SoftDeleteStatusAttribute />
              <HardDelete>TreatAsHard</HardDelete>
              <SoftDelete>None</SoftDelete>
            </DeprovisioningModel>
          </EntrySchema>
        </EntriesSchema>
        <Partitions>
          <Partition>
            <Id>ba05a46c-9390-4b85-9019-a1811be08949</Id>
            <Name>default</Name>
            <DN>default</DN>
          </Partition>
        </Partitions>
        <ExportPasswordInFirstPass>False</ExportPasswordInFirstPass>
        <SupportPassword>False</SupportPassword>
      </Schema>
      <ECMAConfig>
        <ECMAFolderPath />
        <LibraryName>Microsoft.IAM.Connector.PowerShell</LibraryName>
        <AutosyncTimer>120</AutosyncTimer>
        <SecretToken>AAEAAAD/////AQAAAAAAAAAMAgAAAFRNaWNyb3NvZnQuRUNNQTJIb3N0LkVuY3J5cHRlZCwgVmVyc2lvbj0xLjEuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPW51bGwFAQAAAChNaWNyb3NvZnQuRUNNQTJIb3N0LkVuY3J5cHRlZC5EYXRhRW5jeXB0AgAAABU8RGF0YT5rX19CYWNraW5nRmllbGQVPFNhbHQ+a19fQmFja2luZ0ZpZWxkAQcCAgAAAAYDAAAAtAJBUUFBQU5DTW5kOEJGZEVSakhvQXdFL0NsK3NCQUFBQXQxMjdENDNmQTBxOGcxVFpvcXVNdlFRQUFBQUNBQUFBQUFBUVpnQUFBQUVBQUNBQUFBQVdrTzZjYWFVYk9HVDAvTEpFS1F4NStJOTM1ajJCRlN1R0xxeUsyc0JvcndBQUFBQU9nQUFBQUFJQUFDQUFBQUJPS05oUEp2S0FhYnBsN3FzdlZUUkl5UkJlNE15YmUvMWFBeURFZ2VGbUpCQUFBQUM2WHRlODM2NHQ0Qlo4U1RIK0FjdFhRQUFBQUdpWTNuQ1k4SHNTMDVHVmFyRXZTZ3JySFluODZJZjVPc051QkEyR2dFbUo0QndsZWs1M1l0amdHbXovUWlTUnBzLzloTUcyVnhqd1Q3UUFjbDdlMlA0PQkEAAAADwQAAACAAAAAAkqvVUJOAfvBBrLQGYraaCdzjJs5EOzX3cMF3G0Rgt+RTg9Xq4GTmFWdSW7auKJFH4ftf2iIBgqq2O2vRKm9RHgVU2O4q1OAQU/ixQMvNfS7CwdceNBWwo7zkrioP3tjFyweM4hzpBHhEPJ8RX3ONEFKpLoFDcgwFAfo8xEmGO4OCw==</SecretToken>
        <ProfileName>CSV</ProfileName>
        <CreationDateTime>Thursday, April 27, 2023 9:09:03 PM</CreationDateTime>
        <ModificationDateTime>Thursday, April 27, 2023 9:22:22 PM</ModificationDateTime>
        <Validated>true</Validated>
      </ECMAConfig>
    </Connector>
  </Connectors>
  <Setting>
    <Port>8585</Port>
    <Certificate>B1059D9236D99040B597C34DC736733870CBF652</Certificate>
  </Setting>
</Configuration>

```


